package org.snakeskin.compiler.units

import com.squareup.kotlinpoet.*
import java.io.File
import java.time.Instant
import java.util.*

/**
 * @author Cameron Earle
 * @version 2/7/2019
 *
 */
object UnitClassGenerator {
    data class FactorKey(val functionName: String, val returnTypeName: String)

    fun generateClass(writeTo: File, unitDefinition: UnitDefinition, group: List<UnitDefinition>) {
        //Generate conversion factors
        val factors = hashMapOf<FactorKey, Double>()
        group.forEach {
            groupElement ->
            var upperFactor = 1.0
            unitDefinition.components.forEachIndexed {
                i, componentElement ->
                val groupComponentElement = groupElement.components[i]
                val componentFactor = componentElement.conversionToBase * groupComponentElement.conversionFromBase
                upperFactor *= componentFactor
            }
            val conversionName = "to${groupElement.name}"
            val className = groupElement.group.split(".").reversed().joinToString("", transform = { it.capitalize() }) + "Measure${groupElement.name}"

            factors[FactorKey(conversionName, className)] = upperFactor

            //println("${unitDefinition.name}:   $conversionName = $upperFactor")
        }

        val thisConversionName = "to${unitDefinition.name}"
        val packageName = "org.snakeskin.measure.${unitDefinition.group}"
        val finalClassName = unitDefinition.group.split(".").reversed().joinToString("", transform = { it.capitalize() }) + "Measure${unitDefinition.name}"

        val typeBuilder = TypeSpec.classBuilder(finalClassName)
                .addModifiers(KModifier.INLINE)
                .addKdoc("This class was automatically generated by the SnakeSkin compiler on ${Date.from(Instant.now())}")
                .primaryConstructor(
                    FunSpec.constructorBuilder().addParameter("value", Double::class).build()
                )
                .addProperty(PropertySpec.builder("value", Double::class).initializer("value").build())

        factors.forEach {
            key, factor ->
            //Add direct conversion functions
            typeBuilder.addFunction(
                    FunSpec.builder(key.functionName)
                            .returns(ClassName(packageName, key.returnTypeName))
                            .addStatement("return ${key.returnTypeName}(value * $factor)")
                            .build()
            )

            //Add arithmetic functions
            typeBuilder.addFunction(
                    FunSpec.builder("plus")
                            .addModifiers(KModifier.OPERATOR)
                            .addParameter("that", ClassName(packageName, key.returnTypeName))
                            .returns(ClassName(packageName, finalClassName))
                            .addStatement("return ${finalClassName}(this.value + that.${thisConversionName}().value)")
                            .build()
            )
            typeBuilder.addFunction(
                    FunSpec.builder("minus")
                            .addModifiers(KModifier.OPERATOR)
                            .addParameter("that", ClassName(packageName, key.returnTypeName))
                            .returns(ClassName(packageName, finalClassName))
                            .addStatement("return ${finalClassName}(this.value - that.${thisConversionName}().value)")
                            .build()
            )
            typeBuilder.addFunction(
                    FunSpec.builder("times")
                            .addModifiers(KModifier.OPERATOR)
                            .addParameter("that", ClassName(packageName, key.returnTypeName))
                            .returns(ClassName(packageName, finalClassName))
                            .addStatement("return ${finalClassName}(this.value * that.${thisConversionName}().value)")
                            .build()
            )
            typeBuilder.addFunction(
                    FunSpec.builder("div")
                            .addModifiers(KModifier.OPERATOR)
                            .addParameter("that", ClassName(packageName, key.returnTypeName))
                            .returns(ClassName(packageName, finalClassName))
                            .addStatement("return ${finalClassName}(this.value / that.${thisConversionName}().value)")
                            .build()
            )
        }

        val file = FileSpec.builder("org.snakeskin.measure.${unitDefinition.group}", finalClassName)
                .addType(typeBuilder.build())
                .build()

        file.writeTo(writeTo)
    }

    fun generateGroup(writeTo: File, group: List<UnitDefinition>) {
        group.forEach {
            generateClass(writeTo, it, group)
        }
    }

    fun generateDsl(writeTo: File, vararg groups: List<UnitDefinition>) {
        val fileBuilder = FileSpec.builder("org.snakeskin.measure", "MeasureDsl")
        groups.forEach {
            group ->
            group.forEach {
                element ->
                val packageName = "org.snakeskin.measure.${element.group}"
                val finalClassName = element.group.split(".").reversed().joinToString("", transform = { it.capitalize() }) + "Measure${element.name}"
                fileBuilder.addProperty(
                        PropertySpec.builder(element.name, ClassName(packageName, finalClassName))
                                .getter(
                                        FunSpec.getterBuilder()
                                                .addCode("return $finalClassName(this)")
                                                .build()
                                )
                                .receiver(Double::class)
                                .build()
                )
            }
        }

        fileBuilder.build().writeTo(writeTo)
    }
}